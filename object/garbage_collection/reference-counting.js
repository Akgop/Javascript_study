/*
Reference-counting GC
"어떤 다른 객체에서도 참조하지 않는 객체"
를 더이상 필요하지 않은 메모리로 판단하여 메모리 해제

문제점: 순환 참조가 발생하면 메모리 해제가 발생하지 않아
       메모리 누수가 발생할 수 있다.
 */

// {a: {b: 2}} 의 위치를 0x12라고 해보자.
// x 가 아래 객체를 참조(0x12)한다.
var x = {
    a: {
        b: 2
    }
};

// y 는 0x12의 복사본을 갖게 되며 0x12를 참조하게 된다.
var y = x;

// 변수 x는 1이라는 값을 새로 갖게 되며
// 더이상 0x12라는 참조값을 갖지 않게 된다.
// y 만 0x12 위치의 객체를 참조하게 된다.
x = 1;

// {b: 2}의 위치는 0x22라고 해보자
// z는 0x22의 복사본을 갖게 되며 0x22를 참조하게 된다.
var z = y.a;
console.log(z); // {b: 2} 출력

// 이 시점에서 GC는 수행되지 않는다.
// why?
// 여전히 {a: {b: 2}} 라는 객체가 변수 y, z에 의해 참조되므로.

// 더이상 변수 y는 0x12를 참조하지 않는다.
y = "yo";

// 이 시점에서도 GC는 수행되지 않는다.
// why?
// {a: {b: 2}} 에서 {b: 2} 가 z에 의해 참조되기 때문이다.

z = null;

// 이 시점에는 GC를 수행한다.
// 더이상 {a: {b: 2}}를 참조하는 변수가 없기 때문이다.
// 즉 해당 객체로의 모든 연결고리가 끊켰다는 말이다.


// 문제점 예시 코드: 순환 참조가 발생하는 경우
function f() {
    var o = {};
    var o2 = {};
    o.a = o2;
    o2.a = o;

    return "leak";
}
f();
// f함수가 끝난 이후 o, o2는 모두 사용되지 않지만,
// reference-counting GC알고리즘에서는
// 참조가 일어나므로 둘 다 GC의 대상으로 판단하지 않는다. --> 메모리 누수
